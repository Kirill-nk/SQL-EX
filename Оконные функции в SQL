Антон встретил Ваню у крыльца здания компании.

— Привет! Как ты рано сегодня, — удивился Антон. – Много задач? Чем мы будем заниматься?

— У меня сегодня встречи с самого утра, — ответил Ваня, — а вот ты направляешься на семинар по оконным функциям. Так что собирай свои конспекты и топай в большую переговорку, будет интересно. Я тоже когда-то этот семинар слушал.
Несмотря на то, что Антон пришел на работу раньше обычного, на семинар он все же опоздал. Лектор уже представился и перешел к теме занятия, поэтому Антон тихонько прошмыгнул в дверь и сел в пустое кресло.

— Сегодня мы с вами поговорим об одном мощном инструменте SQL, который называется Оконные функции, — начал лектор. С функциями различных видов вы уже сталкивались ранее: строчные функции для обработки строчных значений в столбце, агрегационные функции для агрегации по столбцу. А что значит оконные функции, непонятно — не с окнами же нам придется работать. Только вот как раз с окнами и придется, но окна будут не стеклянные, как вы привыкли, а интервальные. 

Для того чтобы понять, что такое окно, сначала вспомним понятие группы. Группой в SQL называется набор строк, в которых один или несколько атрибутов принимают одинаковые значения (именно таким образом формируется группа, когда мы используем оператор GROUP BY). Так вот, окно — это набор строк внутри группы, этот набор может формироваться совершенно по-разному. Давайте рассмотрим небольшую таблицу с действиями абонентов subscrib_actions, она имеет 4 столбца:

action_dt — дата совершения действия;
action_type — тип действия абонента;
client_nm — имя абонента;
action_info — направление действия абонента (входящее/исходящее).

Если мы разделим всю таблицу по типу событий, то получится две группы — звонки и смс-сообщения:

Несмотря на то, что Антон пришел на работу раньше обычного, на семинар он все же опоздал. Лектор уже представился и перешел к теме занятия, поэтому Антон тихонько прошмыгнул в дверь и сел в пустое кресло.

— Сегодня мы с вами поговорим об одном мощном инструменте SQL, который называется Оконные функции, — начал лектор. С функциями различных видов вы уже сталкивались ранее: строчные функции для обработки строчных значений в столбце, агрегационные функции для агрегации по столбцу. А что значит оконные функции, непонятно — не с окнами же нам придется работать. Только вот как раз с окнами и придется, но окна будут не стеклянные, как вы привыкли, а интервальные. 

Для того чтобы понять, что такое окно, сначала вспомним понятие группы. Группой в SQL называется набор строк, в которых один или несколько атрибутов принимают одинаковые значения (именно таким образом формируется группа, когда мы используем оператор GROUP BY). Так вот, окно — это набор строк внутри группы, этот набор может формироваться совершенно по-разному. Давайте рассмотрим небольшую таблицу с действиями абонентов subscrib_actions, она имеет 4 столбца:

action_dt — дата совершения действия;
action_type — тип действия абонента;
client_nm — имя абонента;
action_info — направление действия абонента (входящее/исходящее).
Если мы разделим всю таблицу по типу событий, то получится две группы — звонки и смс-сообщения:

Внутри каждой группы мы можем выделить окна различными способами. Например, окно может включать в себя все строки группы, тогда оно будет выглядеть следующим образом:

Если же мы в каждой группе отсортируем записи по какому-то полю (возьмем для удобства дату действия абонента action_dt), то сможем воспользоваться не только самими записями, но и их порядком в группе. Так, например, можно сформировать окно с первой строки в группе до текущей, на рисунке ниже видно, что таким образом для первой группы сформируются три различных окна, а для второй целых шесть:
Можно придумать множество вариантов формирования окон, а какой нужен именно вам — зависит от конкретной задачи. По умолчанию если в конструкции оконных функций нет сортировки, то окно будет совпадать с группой (как в первом примере), а если есть сортировка, то окно формируется с первой по текущую строку (как во втором примере).

Какие еще существуют инструменты управления размером окна помимо использования сортировки, мы обсудим в последнем блоке этого раздела.

В этом блоке мы поговорили о понятии окна, а далее разберемся с синтаксисом нового инструмента.

Базовый синтаксис оконной функции
У оконных функций синтаксис отличается от синтаксиса всех видов функций, которые вы изучали ранее. Итак, конструкция оконной функции состоит из нескольких блоков:

ИМЯ_ФУНКЦИИ(col0) OVER (PARTITION BY col1[, col2, …] ORDER BY col3[, col4, …] asc/desc)
ИМЯ_ФУНКЦИИ(col0) — наименование функции, которая будет использована для преобразования данных в столбце col0. Например, для расчета последней (максимальной) даты action_dt (в таблице subscrib_actions) необходимо вместо ИМЯ_ФУНКЦИИ указать MAX, а вместо col0 указать наименование столбца — action_dt. В конструкции оконной функции этот блок является обязательным.

OVER — ключевое слово, сигнализирующее об использовании оконной конструкции, является обязательным.

PARTITION BY col1[, col2, …] — в этом блоке указывается поле или набор полей, определяющих окно преобразований. Например, если после PARTITION BY указать атрибут action_type, то в таблице будут созданы два окна — звонки и сообщения. 
Блок PARTITION BY необязательный, однако при его отсутствии вся таблица является одним окном.

ORDER BY col3[, col4, …] asc/desc — эта конструкция используется для упорядочивания строк внутри окна. При отсутствии параметров asc и desc сортировка будет произведена по возрастанию. Оператор сортировки синтаксически не является обязательным в конструкции оконной функции, однако все преобразования, требующие упорядоченных строк, используются только совместно с этим оператором.

В SQL исполнитель программ запускает оконные функции перед ORDER BY и SELECT, поэтому они могут быть использованы только внутри этих операторов.

Примечание:

некоторые вендоры (например, Teradata) предлагают еще один оператор для работы с оконными функциями — QUALIFY. Это оператор фильтрации для результатов работы оконных функций (аналог WHERE, но для оконных функций). Однако в стандарте SQL этот оператор отсутствует и поэтому в СУБД встречается редко.

Мы разобрали базовый синтаксис оконных конструкций, однако все еще непонятно, какие функции можно использовать вместо ИМЯ_ФУНКЦИИ(col0).

Выделяют три основные группы функций, которые используются вместе с оконными конструкциями:

Каждую из приведенных выше функций можно использовать в оконной конструкции вместо ИМЯ_ФУНКЦИИ(col0).

Примечание:

на схеме выше отражены основные функции, которые используют совместно с оконными конструкциями при работе с данными. Однако дополнительно выделяют еще один подвид функций — аналитические. Это функции, которые используются в специфических задачах аналитики для расчета параметров распределения данных — например, стандартного отклонения или дисперсии ряда чисел. Перечень этих функций вы можете узнать в документации вашей СУБД.

Также иногда в литературе термин оконные функции заменяют на аналитические. В этом случае понять, что имел в виду автор — все оконные функции или только одну группу, можно только из контекста.

Теперь давайте рассмотрим области и специфику использования каждой группы функций.

Ранжирующие функции
Ранжирующие функции RANK(), DENSE_RANK() и ROW_NUMBER() используются для расчета порядкового номера строки в окне. В отличие от всех ранее изученных вами функций, они не требуют аргумента, поэтому в скобках всегда пусто.

Важно!

Все ранжирующие функции возвращают порядковый номер, поэтому при их использовании необходимо в конструкции оконной функции указывать оператор сортировки ORDER BY.

Казалось бы, зачем нужны три различные функции для расчета номера строки? Хватило бы и одной! Но сейчас мы на примере убедимся, что одной, к сожалению, не хватает.

Рассмотрим таблицу subscrib_actions с действиями абонента Сони. Давайте пронумеруем каждую строку в разрезе тип действия абонента в порядке возрастания даты события. Интуитивно мы понимаем, что строка с самой ранней датой должна иметь самый маленький номер, а с самой поздней датой — самый большой. Но что же будет происходить, если у строк одна и та же дата? Вот тут как раз все три функции ведут себя по разному. 

Давайте напишем запрос, который выведет исходную таблицу с номерами строк. Для начала определимся с окном расчета показателя. Поскольку мы хотим отдельно для каждого типа действия абонента (звонок или смс) посчитать номер строки, после PARTITION BY необходимо поставить action_type. Как мы понимаем, номер строки указывается не случайным образом, а упорядоченно по возрастанию или убыванию некоторого параметра. В нашем случае необходимо, чтобы номер увеличивался с возрастанием даты действия, поэтому после оператора ORDER BY указываем атрибут action_dt. Параметр asc можно не указывать, поскольку по умолчанию сортировка всегда идет по возрастанию. В остальном в запросе три новых поля будут отличаться только наименованием первой функции:

SELECT
   *,
 	ROW_NUMBER() OVER (PARTITION BY action_type ORDER BY action_dt) as row_num,
 	DENSE_RANK() OVER (PARTITION BY action_type ORDER BY action_dt) as dr_num,
   	RANK() OVER (PARTITION BY action_type ORDER BY action_dt) as r_num
FROM subscrib_actions;
И вот что вывел запрос:


Функция ROW_NUMBER() для каждой строки укажет уникальный порядковый номер, независимо от того, одинаковые или разные значения в столбце для сортировки. Если столбец для сортировки имеет несколько одинаковых значений, то номер строки будет определен случайным образом, то есть при каждом новом перестроении выборки номера для таких строк могут меняться (напоминаем, что в таблице строки могут и не быть упорядоченными). Эту особенность функции ROW_NUMBER() стоит помнить при использовании.

В отличие от ROW_NUMBER() функции DENSE_RANK() и RANK() для строк с одинаковыми значениями в столбце сортировки указывают одинаковые номера, однако делают это по-разному.

Функция DENSE_RANK() присваивает строке номер группы. В нашей таблице абонент Соня отправляла sms-сообщения в три разные даты, поэтому групп будет три: 

11 февраля — это первая группа;
13 февраля — вторая группа;
14 февраля — третья.
Функция RANK() присваивает всему набору строк с одинаковыми значениями в столбце сортировки порядковый номер первой строки, входящей в этот набор. То есть для sms, отправленных 11.02, функция укажет порядковый номер 1, а для сообщений от 13.02 уже 4, поскольку 11 февраля было отправлено первое сообщение, а 13 февраля — уже четвертое.
Теперь разберем, как работают функции смещения в оконных конструкциях

Функции смещения
Иногда для решения задачи требуется «подсмотреть», что происходит в соседних строках. Примером такой задачи является расчет изменения прибыли компании от месяца к месяцу. Например, есть отчет о прибыли некоторой компании profit_report, он содержит три поля:

BRANCH_NM – филиал компании;
MONTH_DT – месяц формирования отчета;
PROFIT_AMT – сумма прибыли компании в отчетном месяце.
Руководитель этой компании хочет ежемесячно для каждого филиала изучать изменение прибыли, полученной в текущем и предыдущем отчетных месяцах. Казалось бы, можно просто поискать прибыль за текущий и предыдущий месяцы и вычесть одно значение из другого. Но если филиалов много, то ежемесячно вручную производить расчет по каждому филиалу может стать объемной задачей. С помощью же оконных функций смещения можно рассчитать подобные показатели, не прибегая к ручной обработке.

Итак, рассмотрим детально все функции смещения.

LAG(col1, [shift], [outbound_value]) — возвращает одно из значений в столбце col1 до текущей строки:
col1 — наименование столбца, в котором происходит поиск предыдущего значения, обязательный аргумент;
shift — целое число, показывающее смещение между текущей строкой и искомой строкой, необязательный аргумент. Если аргумент не заполнен, то по умолчанию заполняется 1, то есть будет выведено предыдущее значение;
outbound_value — значение, которое принимает новое поле, если поиск вышел за рамки столбца (например, запрос находится на 2-й строке таблицы, а вы хотите вернуть строку, идущую на 3 позиции раньше), необязательный аргумент. Если аргумент не заполнен, то по умолчанию заполняется NULL-значением.
LEAD(col1, [shift], [outbound_value]) — возвращает одно из значений в столбце col1 после текущей строки:
col1 — наименование столбца, в котором происходит поиск последующего значения, обязательный аргумент;
shift — целое число, показывающее смещение между текущей строкой и искомой строкой, необязательный аргумент. Если аргумент не заполнен, то по умолчанию заполняется 1, то есть будет выведено следующее значение;
outbound_value — значение, которое принимает новое поле, если поиск вышел за рамки столбца (например, запрос находится на последней строке таблицы, а вы хотите вывести следующую), необязательный аргумент. Если аргумент не заполнен, то по умолчанию заполняется NULL-значением.
FIRST_VALUE(col1) — возвращает первое значение столбца col1 в окне:
col1 — наименование столбца, в котором происходит поиск, обязательный аргумент.
LAST_VALUE(col1) — возвращает последнее значение столбца col1 в окне:
col1 — наименование столбца, в котором происходит поиск, обязательный аргумент.


Важно! 

Все функции смещения возвращают значение из упорядоченной выборки, поэтому при их использовании необходимо в конструкции оконной функции указывать оператор сортировки ORDER BY (а поскольку появился оператор сортировки, сразу вспоминаем, что окна теперь формируются с первой строки по текущую).

Давайте на примере отчета profit_report рассмотрим использование функций смещения. Руководитель компании хочет, чтобы в новом отчете для каждого филиала были рассчитаны два показателя:

изменение прибыли от месяца к месяцу;
на сколько процентов изменилась прибыль в каждом месяце относительно первого месяца существования филиала.
Для расчета этих показателей необходимо для каждого отчетного месяца узнать прибыль филиала:

в текущем месяце;
в предыдущем месяце;
в первом месяце существования филиала (для нас это будет месяц, в котором у филиала появилась прибыль).
Отчет должен быть построен в разрезе филиала. Это значит, что окна в таблице будут созданы на основе значений поля branch_nm, поэтому после PARTITION BY мы укажем этот атрибут. 

Информация о прибыли в текущем отчетном месяце — это просто поле profit_amt, а вот прибыль в других месяцах нам предстоит найти. Для того чтобы вытянуть данные о прибыли за предыдущий месяц, необходимо использовать функцию LAG(), а за первый месяц — функцию FIRST_VALUE(). В обе функции в качестве аргумента передаем поле profit_amt. Не забываем, что строки в окне должны быть отсортированы по возрастанию отчетного месяца, поэтому следует добавить оператор ORDER BY в оконную конструкцию.

Для начала выведем только прибыль компании за различные периоды:
SELECT
  branch_nm,
  month_dt,
  profit_amt as current_profit_amt,
  -- для каждой строки находим прибыль в предыдущем месяце
  LAG(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as prev_profit_amt,
  --  для каждой строки находим прибыль в первом месяце существования  филиала
  FIRST_VALUE(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as first_profit_amt
FROM profit_report;

Теперь получается такая таблица:
При запуске скрипта исполнитель программ сначала разделил всю таблицу на два окна — Центральный и Северо-Западный филиалы, а после в каждом окне отсортировал строки по возрастанию отчетного месяца month_dt. Далее функция LAG() «заглянула» в рамках окна в предыдущую строку и подтянула значение прибыли из этой строки, а функция FIRST_VALUE() просто «запомнила» значение прибыли, которую заработал филиал в первый месяц своего существования, и проставила ее в поле first_profit_amt.

Поле prev_profit_amt приняло значение NULL для первых месяцев существования филиалов, поскольку для них еще не существует предыдущего значения. В нашем случае правильнее NULL заменить на 0, поэтому доработаем наш запрос, добавив третий аргумент в функцию LAG():
SELECT
  branch_nm,
  month_dt,
  profit_amt as current_profit_amt,
  -- для каждой строки находим прибыль в предыдущем месяце
  LAG(profit_amt, 1, 0) OVER (PARTITION BY branch_nm ORDER BY month_dt) as prev_profit_amt,
  -- для каждой строки находим прибыль в первом месяце
  FIRST_VALUE(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as first_profit_amt
FROM profit_report;

И NULL-значения заменяются на нули:
В общем, самое сложное позади, осталось только провести арифметические действия с новыми полями. С точки зрения синтаксиса мы можем проводить любые действия с оконными функциями в операторе SELECT, однако выражение

PROFIT_AMT –  LAG(profit_amt, 1, 0) OVER (PARTITION BY branch_nm ORDER BY month_dt)
выглядит очень массивно и поэтому плохо воспринимается. Давайте мы вынесем расчет всех оконных функций в подзапрос и при подсчете необходимых показателей уже воспользуемся их результатом:

WITH prep as (
SELECT
 			branch_nm,
  			month_dt,
  			profit_amt as current_profit_amt,
  			-- для каждой строки находим прибыль в предыдущем месяце
  			LAG(profit_amt, 1, 0) OVER (PARTITION BY branch_nm ORDER BY month_dt) as prev_profit_amt,
  			-- для каждой строки находим прибыль в первом месяце
FIRST_VALUE(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as first_profit_amt
FROM profit_report)
SELECT
	branch_nm, 
	month_dt,
	current_profit_amt - prev_profit_amt as profit_delta_amt, 
	(current_profit_amt - first_profit_amt)*100/first_profit_amt as cur_to_first_profit_pct
FROM prep;


Вот и сформирован отчет, который хотел получить руководитель компании.

Далее мы познакомимся с последней группой функций, которые используются в оконных конструкциях — агрегационными

Агрегационные оконные функции и группировка
Как ранжирующие, так и функции смещения в своей работе требуют, чтобы в каждой группе строки были упорядочены, то есть использование оператора сортировки ORDER BY для них обязательно, в то время как для агрегационных функций этот оператор обязательным не является. Поэтому при использовании агрегационных функций мы можем работать с данными сразу всей группы (если нет сортировки), а можем только с ее частью (если есть сортировка).

Давайте разберем задачу и убедимся, что наличие сортировки действительно влияет на результат вычислений. Руководитель компании никак не успокоится и требует сформировать отчет, в котором будут отражены:

кумулятивная ежемесячная прибыль по каждому филиалу с начала работы филиала;
доля прибыли филиала в каждом месяце от его общей прибыли.

Примечание:

кумулятивная ежемесячная прибыль или прибыль с накоплением — это сумма прибыли с первого месяца отчетного периода по текущий. То есть для Центрального филиала мы должны получить следующие результаты:

Поскольку кумулятивная прибыль — это сумма c первой строки по текущую, мы понимаем, что окно должно формироваться с учетом результатов сортировки. Также вспоминаем, что руководитель требует расчета показателя в разрезе филиала. Тогда оконная функция для прибыли с нарастающим итогом выглядит следующим образом:

SUM(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt)
Теперь поговорим о втором показателе — доле прибыли филиала в каждом месяце от его суммарной прибыли. Для расчета этого показателя необходимо знать две суммы – сумму прибыли филиала в конкретном месяце и сумму прибыли филиала за весь период, после чего разделить одну на вторую. С первой суммой все ясно — это и есть PROFIT_AMT, а вот как быть со второй? Здесь нам и помогут оконные функции, но уже без использования сортировки, поскольку сумму нужно рассчитать по всем строкам группы. То есть в этом случае оконная функция превращается в

SUM(profit_amt) OVER (PARTITION BY branch_nm)
Для начала напишем запрос, который выведет результаты двух оконных конструкций:

SELECT
	branch_nm,
	month_dt,
	profit_amt,
	SUM(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as profit_accum_amt,
	SUM(profit_amt) OVER (PARTITION BY branch_nm) as all_profit_amt
FROM profit_report
GROUP BY action_type;
Вернет следующий результат:

А для того чтобы получить долю прибыли филиала в каждом месяце от суммарной годовой прибыли, необходимо столбец profit_amt разделить на all_profit_amt, поэтому немного преобразуем полученный ранее запрос:

SELECT
	branch_nm,
	month_dt,
	profit_amt,
	SUM(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as profit_accum_amt,
	profit_amt/SUM(profit_amt) OVER (PARTITION BY branch_nm) as month_profit_pct
FROM profit_report
GROUP BY action_type;
Теперь получается именно тот отчет, который хочет использовать в работе руководитель компании:


Важно!

Как вы могли заметить, оконные функции никак не повлияли на количество записей в итоговой таблице, поэтому, в отличие от GROUP BY, при их использовании можно выводить любые поля независимо от того, участвуют они в формировании окна или нет.

Другие способы изменения размера окон
Ранее мы с вами обсудили базовый синтаксис оконной функции. Напомним, что конструкция оконной функции состоит из четырех блоков:

функция преобразования;
ключевое слово OVER;
блок формирования окна с оператором PARTITION BY;
блок сортировки с оператором ORDER BY.
Однако в оконных конструкциях есть пятый блок. Он помогает выделить внутри окна подмножество и проводить все вычисления в этом подмножестве строк. Этот блок располагается после этапа сортировки и имеет следующую конструкцию:

ROWS BETWEEN начало_подмножества AND конец_подмножества
Начало подмножества можно определять следующими выражениями:

N PRECEDING — N строк до текущей строки;
CURRENT ROW — текущая строка;
UNBOUNDED PRECEDING — все строки, предшествующие текущей.

Конец подмножества можно определять следующими выражениями:

N FOLLOWING — N строк после текущей строки;
CURRENT ROW — текущая строка;
UNBOUNDED FOLLOWING — все последующие строки.
Приведем некоторые примеры формирования подмножества.

Все строки в окне 

ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 
— таким образом будет формироваться окно, если в конструкции оконной функции НЕ указан оператор сортировки:


С первой строки в окне до текущей 

ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  
— таким образом будет формироваться окно, если в конструкции оконной функции указан оператор сортировки:


С текущей до последней строки в окне 

ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING 

Одна строка до текущей и текущая строка 

ROWS BETWEEN 1 PRECEDING AND CURRENT ROW

Обычно подмножества используют для расчета специфических бизнес-показателей, например помесячного расчета прибыли с накоплением с начала года или сумму прибыли за несколько месяцев в «скользящем окне».

Примечание:

скользящим окном называется диапазон строк, который перемещается вниз или вверх по таблице (сами строки остаются на своих местах, двигается только диапазон), т.е. создается ощущение, что окно скользит.

Блок формирования подмножеств в конструкции оконной функции является необязательным, и при его отсутствии по умолчанию функции работают по высоте всего окна, что равносильно выражению

ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 
Однако есть один важный нюанс: в случае, если в оконной конструкции есть оператор ORDER BY, каждое окно по умолчанию превращается в подмножество строк с первой строки до текущей, то есть в сортировку помимо упорядочивания строк неявно добавляется условие

ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
Если добавить к оператору сортировки еще и условие на границы подмножества, то в таком случае ORDER BY будет влиять только на порядок строк в окне. 

Многие начинающие специалисты не знают об этих особенностях, что приводит к ошибкам при расчетах.

Давайте разберем пример, который показывает различия в работе алгоритмов. На основе отчета profit_report рассчитаем сумму прибыли за весь период для каждого филиала, но сделаем это тремя разными способами — без оператора сортировки, с оператором сортировки и с оператором сортировки, явно указав границы подмножества.

SELECT
	branch_nm, 
	month_dt,
	profit_amt,
	-- сумма прибыли
	SUM(profit_amt) OVER (PARTITION BY branch_nm) as  profit_amt_1,
	-- сумма прибыли с сортировкой
	SUM(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt) as  profit_amt_2,
	-- сумма прибыли с сортировкой и указанием границы подмножества 
	SUM(profit_amt) OVER (PARTITION BY branch_nm ORDER BY month_dt 
	ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as  profit_amt_3
FROM profit_report;

В первом поле для каждого филиала будет указана одна и та же сумма, потому что агрегация идет для каждой строки таблицы сразу по всему окну. 

Во втором поле из-за того, что указали оператор ORDER BY, но не указали границы подмножества, будет рассчитана сумма с первой строки окна по текущую, то есть для первого месяца это будет только прибыль в первом месяце, для второго месяца – сумма прибыли в первый и второй месяцы и так далее до конца окна.

В третьем поле помимо оператора сортировки ORDER BY мы также указали границы подмножества — с самой первой строки окна до последней, то есть алгоритм расчета будет как у поля profit_amt_1.

— Ну вот и все, — резюмировал лектор, — управились за один день, молодцы! Тема сложная, но я постарался разобрать все с примерами, чтобы вам было легче. 

«Голова просто кипит, — подумал Антон, выходя из аудитории, — но примеров и правда много, буду на них ориентироваться при использовании теории в боевых задачах».


Оконная функция в SQL — это конструкция, работающая с окнами, то есть подмножествами строк в группе. Окно иногда может совпадать с самой группой, однако мы выяснили, что оконные функции радикально отличаются от группировки:
оконные функции не влияют на количество строк в результате их применения;
оконные функции, в отличие от GROUP BY, допускают вывод всех полей из таблицы — даже тех, которые не участвуют в формировании окна;
помимо агрегационных функций оконные конструкции также работают с ранжирующими функциями и функциями смещения.
Конструкция оконной функции состоит из пяти блоков:
функция преобразования — обязательный блок;
ключевое слово OVER — обязательный блок; 
блок формирования окна с оператором PARTITION BY — необязательный блок;
блок сортировки с оператором ORDER BY — условно обязательный блок;
блок формирования подмножества внутри окна ROWS BETWEEN — необязательный блок.
